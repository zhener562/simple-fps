## 任意人数対戦への拡張計画

この計画は、現在の2人対戦のゲームを任意人数での対戦に拡張するために必要なバックエンド（Rust）とフロントエンド（TypeScript）の変更点を詳述します。

### 1. バックエンドの変更 (Rust: `src/signaling.rs`, `src/main.rs`)

シグナリングサーバーは、クライアント間のWebRTC接続の確立とゲーム状態の同期を仲介する役割を担っています。任意人数対戦をサポートするために、主にルーム管理機能を追加します。

**1.1. `SignalingMessage`構造体の移動**
*   `main.rs`に定義されている`SignalingMessage`構造体を`signaling.rs`に移動し、両方のファイルからアクセスできるようにします。これにより、メッセージ定義の一元管理が可能になります。

**1.2. `SignalingServer`のルーム管理機能の追加**
*   `SignalingServer`構造体に、ルームIDとそこに参加しているクライアントIDのセットをマッピングする`rooms: Arc<Mutex<HashMap<String, HashSet<String>>>>`フィールドを追加します。
*   `SignalingServer::new`関数内で、この`rooms` HashMapを初期化します。
*   **`join_room(client_id: String, room_id: String)`メソッドの追加:** 指定されたクライアントを特定のルームに追加します。ルームが存在しない場合は新しく作成します。
*   **`leave_room(client_id: &str, room_id: &str)`メソッドの追加:** 指定されたクライアントをルームから削除します。ルームが空になった場合は、そのルームを削除します。
*   **`broadcast_to_room(room_id: &str, message: SignalingMessage, exclude: Option<&str>)`メソッドの追加:** 特定のルーム内のすべてのクライアント（除外指定があれば除く）にメッセージをブロードキャストします。既存の`broadcast`関数を置き換えるか、共存させます。

**1.3. `SignalingSession`の更新**
*   `SignalingSession`構造体に、セッションが現在参加しているルームのIDを追跡するための`room_id: Option<String>`フィールドを追加します。
*   **`started`メソッドの更新:** クライアントが接続した際に、初期のルーム割り当てロジック（またはクライアントからの`join-room`メッセージを待つプレースホルダー）を考慮します。
*   **`stopped`メソッドの更新:** クライアントが切断された際に、`self.server.leave_room`を呼び出して、そのクライアントが参加していたルームから適切に削除されるようにします。
*   **`handle`メソッドの更新:**
    *   `"join-room"`メッセージタイプの場合: クライアントが指定したルームに参加できるように、新しく追加した`self.server.join_room`メソッドを呼び出します。その後、ルーム内の他のクライアントに新しいユーザーが参加したことを通知するメッセージを`broadcast_to_room`で送信します。
    *   `"game-state"`メッセージタイプの場合: ゲーム状態の更新を、クライアントが現在参加しているルーム内でのみブロードキャストするように`self.server.broadcast_to_room`を使用します。
    *   `"offer"`, `"answer"`, `"ice-candidate"`メッセージタイプは、引き続き特定のターゲットクライアントに転送されます。

### 2. フロントエンドの変更 (TypeScript: `static/index.tsx`)

フロントエンドは、複数のピア接続を管理し、動的にリモートプレイヤーをレンダリングし、マルチプレイヤーゲームロジックを適応させる必要があります。

**2.1. 複数のピア接続の管理**
*   現在の単一の`peerConnection`と`dataChannel`変数を、接続されている各リモートピアの`RTCPeerConnection`と`RTCDataChannel`インスタンスを格納する`Map<string, RTCPeerConnection>`と`Map<string, RTCDataChannel>`（リモートピアの`clientId`をキーとする）に置き換えます。
*   `initPeerConnection`、`createAutomaticOffer`、`handleRemoteOffer`、`handleRemoteAnswer`、`handleRemoteIceCandidate`などのWebRTC関連関数を、複数のピア接続を適切に管理するように更新します。特に、`handleRemoteOffer`では、新しいピアからのオファーを受け取った際に新しい`RTCPeerConnection`インスタンスを作成する必要があります。

**2.2. 動的なリモートプレイヤー管理**
*   単一の`remotePlayerMesh`変数を、すべてのリモートプレイヤーの`THREE.Group`オブジェクトを格納する`Map<string, THREE.Group>`に置き換えます。
*   シグナリングサーバーからの`"user-joined"`メッセージを受信した際に、新しいリモートプレイヤーのメッシュを動的に作成し、シーンに追加するロジックを実装します。
*   プレイヤーが切断された場合（例: WebSocketの切断、WebRTC接続のクローズ）に、対応するリモートプレイヤーのメッシュをシーンから削除し、リソースを解放するロジックを実装します。

**2.3. シグナリングメッセージの処理の適応**
*   **`"user-joined"`:** このメッセージを受信した際、新しいユーザーがルームに参加したことを示します。現在のクライアントは、この新しいユーザーとの間で新しいWebRTC接続（オファーの作成）を開始する必要があります。
*   **`"offer"`, `"answer"`, `"ice-candidate"`:** これらのメッセージには、送信元とターゲットのクライアントIDが含まれるようにし、対応する`RTCPeerConnection`インスタンスに正しくルーティングされるように処理を更新します。
*   **`"game-state"`:** `sendGameEvent`関数を修正し、現在接続されているすべての`dataChannel`を反復処理してゲーム状態を送信するようにします。`PlayerState`インターフェースには、どのプレイヤーの状態であるかを識別するために、送信者の`clientId`を含める必要があるかもしれません。

**2.4. UIの更新**
*   現在の`webrtc-signaling-panel`は2人対戦用に設計されています。これを、現在のルームに接続しているすべてのプレイヤーのリストを表示できるように更新します。
*   ユーザーが特定のルームに参加したり、新しいルームを作成したりするためのUI要素（例: ルームID入力フィールド、ルーム作成ボタン）を追加することを検討します。

**2.5. ゲームロジックの適応**
*   **スポーンポイント:** `getSpawnSeedOffset`や`selectRandomSpawnPoint`などのスポーンポイント関連の関数を、N人のプレイヤーに対応できるように一般化します。例えば、各プレイヤーが互いに十分な距離を保ってスポーンするように調整します。
*   **スコア/ゲームオーバー:** `myScore`と`opponentScore`を、すべてのプレイヤーのスコアを追跡するための`Map<string, number>`に変更します。N人対戦の場合のゲームオーバー条件（例: 最後の1人、チームデスマッチなど）を再評価し、それに応じてロジックを更新します。
*   **衝突検出:** プレイヤー間の衝突検出が必要な場合、すべてのリモートプレイヤーのメッシュを反復処理して衝突をチェックするようにロジックを更新します。
*   **プロジェクタイル処理:** リモートプレイヤーが発射したプロジェクタイルを、それらを発射したプレイヤーの`clientId`に関連付け、適切に処理できるようにします。

---

この計画は、任意人数対戦を実装するための主要なステップを網羅しています。まずはバックエンドのルーム管理機能の実装から着手し、その後フロントエンドの変更に進むのが効率的です。